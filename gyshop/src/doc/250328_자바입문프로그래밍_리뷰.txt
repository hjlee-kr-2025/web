비트 (bit) : 0과 1을 표현하는 것
: 2진수의 최소단위
  0 과 1을 가지고 숫자하나를 표현하는 것
바이트 (byte) : 1byte = 8bit
: 8자리 2진수
일반: 00000000 ~ 11111111 : 0~255
음수를 사용하려면 숫자앞에 -를 붙이면 됩니다.

컴퓨터에서는 -값을 사용하려면 +와 -구분을 위해서 비트1개를 사용해야 합니다.

00000000
00000001  -> 보수 11111111

00000010  -> 11111101 + 1
             = 11111110  = -2
00000011
00000100
....
01111111 : +중에 제일큰수
여기서 1을 더하면
10000001 : 음수중에 제일작은

변수 : 변하는 수(값)
JAVA에서는 변수를 선언할 때 자료형이 필요합니다.
기본자료형 (8가지)
- 기본자료형을 제외하는 나머지는 클래스자료형(참조자료형) 입니다.
*정수형 : byte(1), short(2), int(4), long(8)
*실수형 : float(4), double(8)
*문자형 : char(2) - unicode
*논리형 : boolean(1)
long type 정수형 : 숫자뒤에 l, L을 붙여 사용합니다.
예)
int num1 = 12;
long num2 = 12L;
float type 실수형 : 숫자뒤에 f, F를 붙여서 사용합니다.
문자형 : '문자' - 작은따옴표안에 문자하나를 넣어서 사용합니다.
논리형 : true , false


** 변수이름
- 영어대문자, 소문자, 숫자, $, _
- 숫자는 처음에 오지 못합니다.
- camel case 방식의 변수이름을 많이 사용합니다.
- "_" 방식의 변수이름

** 상수 - 고정된 값
final 예약어를 사용하여 변수를 선언하면 상수가 됩니다.
- 상수의 이름은 자바에서는 대문자로 많이 사용합니다.

** 형변환 : 자료형을 변경하는 것
- 묵시적 형변환
: 작은곳에서 큰곳은 자료형없이 자동으로 진행됩니다.
- 명시적 형변환 (강제캐스팅)
: 큰자료형을 작은자료형에 넣을때는 변환되는 자료형을 표시해야 합니다.
예) short num1 = 258;
2진수:	00000001 00000010
byte num2 = (byte)num1;
num2 : 00000010 (하위바이트)만 남습니다. 그래서 num2 는 2가 됩니다.

기본자료형에 대응하는 클래스자료형
===> Wapper class
* byte		: Byte
* short		: Short
* int		: Integer
* long		: Long
* float		: Float
* double	: Double
* char		: Character
* boolean	: Boolean
* 		: String(문자열)

((( 연산자 )))
** 산술연산자 : + , - , * , / , %
++ : 증가연산자
-- : 감소연산자
==> 변수에서만 사용할 수 있습니다.
==> 단항연산자 입니다.
사용예)
int num1 = 0;
++num1; ==> 잘모르면 추천
num1++;
System.out.println("num1 = " + num1);
===> num1 = 2

** 관계연산자
> , >= , < , <= , == , !=

** 논리연산자
&&(AND), ||(OR) : 2개의 값을 가지고 사용
!(NOT) : 1개의 값을 가지고 사용

** 3항 연산자
(조건식)?참:거짓;


4장: 제어흐름 이해하기
** 조건문
if문, if~else문, if~else if~else 문
if(조건) {
	참일때 실행합니다.
}
-----------------
if(조건) {
	참일때 실행합니다.
}
else {
	거짓일때 실행합니다.
}
------------
if(조건1) {
	조건1이 참일때
}
else if(조건2) {
	조건1이 거짓, 조건2 참
}
else {
	조건1 거짓, 조건2 거짓
}

<<switch 문, case, break>>
switch (변수) {
case 값1:
	변수데이터가 값1일때 이곳으로
	break; // switch 블럭을 빠져나갑니다.
case 값2:
	변수데이터가 값2일때
	break;
default:
	// 이부분은 구현이 안되어도 괜찮습니다. case에 값이 없을때 이곳으로 넘어옵니다.
}

반복문 - 동일코드를 반복적으로 사용할 때 사용하는 명령문입니다.
** while문, do~while문, for문
while(조건) {
	반복적으로 실행할 코드;
}
--> 조건이 참인 동안 반복해서 블럭안의 내용이 처리됩니다.
while(true){
	무한반복코드
}
--> while문의 조건을 true로 하면 무한반복되는 프로그램을 작성할 수 있습니다.
do {
	최초1번 무조건 진행
	2번째부터 참일때 처리
} while(조건);

for(1 ; 2 ; 4) {
	3
}
for문의 진행순서
1->2(참)->3->4->2(참)->3->4->...
->2(거짓) : 블럭나옴

둘째마당: 자바의 핵심,
객체 지향 프로그래밍
(OOP: Object Oriented Programming)
객체 지향 프로그래밍을 위해 만들어진 것이 java의 클래스 입니다.

클래스의 구성
- 멤버변수 : 클래스 내부에 선언되어있는 변수
- 메서드(함수) : 클래스 내부의 함수
public class Student {
	private int studentNo;
	private String studentName;

	public int getStudentNo(){
		return studentNo;
	}
}

*** static 변수
사용법(선언방법)
public static 자료형 변수이름 = 초기값;
예) public static int serialNum = 1000;
- static 변수의 다른이름은 클래스변수라고도 합니다.
- 클래스의 생성없이 사용할 수 있는 변수입니다.
public class Student {
	public static int serialNum = 1000;
}
이 변수를 다른 클래스에서 사용하려고 하면
Student.serialNum 으로 사용하면 됩니다.
클래스가 생성자를 사용해서 구현된다고 하더라도
static 변수는 추가로 할당되지 않고 같은 클래스 인스턴스에서 공유되어 사용됩니다.

((((( 7장 )))))
배열과 ArrayList
: 같은 자료형의 데이터를 순서대로 저장하고 사용하는 것
: 인덱스: 0번부터 시작합니다.

배열은 처음 만들때 크기가 정해집니다.
-- 크기변경 불가능
ArrayList는 데이터를 자유롭게 추가하고 삭제하는 것이 가능하고, 저장된 데이터의 개수를 손쉽게 알수 있습니다



8-10장 상속, 추상클래스, 인터페이스
--> 상속이 없다면 추상클래스, 인터페이스는 사용할 수 없습니다.
--> 추상클래스, 인터페이스는 생성자를 사용할 수 없습니다.(메모리할당불가)
--> 왜 할당이 안되도록 자바에서 막아놨냐?
   (구현안 된 메서드가 있기 때문입니다.)
   abstract 메서드가 존재하기 때문입니다.
--> 추상클래스, 인터페이스는 상속을 받을 클래스에서 abstract 메서드의 구현부를
		만들고(프로그램밍하고) 자녀클래스의 생성자를 통해서 메모리할당이 됩니다.
--> 함수의 재정의 (@Override) - 오버라이팅
  : 부모클래스의 함수 (리턴자료형, 함수이름, 매개변수동일 하게 사용)
    -> {} 처리부만 새롭게 작성하는 것을 오버라이팅이라고 합니다.
--> 함수위에 @Override 라고 어노테이션을 붙이면
		부모클래스에 동일한 함수가 없으면 error를 발생시킵니다.
		
부모클래스(일반클래스, 추상클래스, 인터페이스)로
선언하고 자녀클래스 생성자로 메모리 할당을 할 수 있습니다.
---> 다형성     
이때 부모클래스와 자녀클래스가 동일한 함수(메서드)가 있고,
처리부는 다르다고 할때
이 변수를 사용해서 메서드를 호출하면, 생성된 자녀클래스의 함수(메서드)처리부가
실행됩니다.









